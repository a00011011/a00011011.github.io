<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[三、函数]]></title>
    <url>%2F2017%2F07%2F22%2F%E4%B8%89%E3%80%81%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[函数形参的默认值在ES5中模拟默认参数123456function makeRequest (url, timeout, callback) &#123; timeout = (typeof timeout !== 'undefined') ? timeout : 2000 callback = (typeof callback !== 'undefined') ? callback : function () &#123;&#125; // ....&#125; ES6中的默认参数值123function (url, timeout = 2000, callback = function () &#123;&#125;) &#123; // ...&#125; 在这个函数中，只有第一个参数被认为是总要传入值，其他两个函数均有默认值，且不需要添加任何校验值是否缺失的代码，所以函数体会更小。 声明函数时，可以为任意参数指定默认值，在已指定默认值的参数后可以继续声明无参数默认值。如：123function (url, timeout = 2000, callback) &#123; // ...&#125; 只有不为第二个参数传入参数或者主动传入undefined时才会使用timeout的默认值。对于默认参数值，null是合法值。传递null，值就为null 默认参数值对arguments对象的影响 arguments对象：传入的参数的集合 在ES6中，如果一个函数使用了默认函数值，arguments对象的行为都将与ES5严格模式下保持一致。默认参数值的存在使得arguments对象保持与命名参数分离。函数命名参数的变化不会对arguments对象产生影响。 默认参数表达式（非原始值传参）12345678910function getValue() &#123; return 5&#125;function add(first, second = getValue()) &#123; return first + second&#125;console.log(add(1)) // 6console.log(add(1, 1)) // 2 注意，当使用函数调用结果作为默认参数时，如果忘记加小括号，则最终传入的是对函数的引用，而不是函数调用结果。 在引用参数默认值时，只允许引用前面参数的值，即先定义的参数不能访问后定义的参数。 默认参数的临时死区默认参数也有临时死区，在这里的参数不能访问。（所以引用临时死区的行为都会报错）123456function add (first = second, second) &#123; return first + second&#125;console.log(add(1, 1)) // 2console.log(add(undefined, 1)) // 抛出错误 函数参数有自己的作用域和临时死区，其与函数体的作用域是各自独立的，也就是说参数的默认值不可访问函数体内声明的变量。 处理无命名参数JavaScript的函数语法规定，无论函数已定义的命名参数有多少，都不限制调用时传入的实际参数数量，调用时总是可以传入任意数量的参数。 ECMAScript5中的无命名参数js提供arguments对象来检查函数的所以参数，如：123456789101112131415161718192021 function pick (object) &#123; let result = Object.create(null) // 从第二个参数开始 for (let i = 1, len = arguments.length; i &lt; len; i++ ) &#123; result[arguments[i]] = object[arguments[i]] &#125; return result&#125;let book = &#123; title: 'es6', author: 'Zakas', year: 2016&#125;let bookData = pick(book, 'author', 'year')console.log(bookData.author) // Zakasconsole.log(bookData.year) // 2016 不定参数在函数的命名参数前添加三个点(…)就表明这个是不定参数，该参数为一个数组，包含着自它之后传入的所有参数，通过这个数组名就可逐一访问里面的参数。如：12345678910 function pick (object, ...keys) &#123; let result = Object.create(null) // 从第二个参数开始 for (let i = 0, len = keys.length; i &lt; len; i++ ) &#123; result[keys[i]] = object[keys[i]] &#125; return result&#125; 函数的length属性统计的是函数命名参数的数量，不定参数的加入不会影响length属性的值。 不定参数的使用限制 每个函数最多只能声明一个不定参数，而且一定放在所有参数的末尾 不定参数不能用于对象字面量setter之中，如：123456let object = &#123; // Uncaught SyntaxError: Setter function argument must not be a rest parameter set name (...value) &#123; console.log(1) &#125;&#125; 原因： 对象字母量setter的参数有且只能有一个参数。 不定参数对arguments对象的影响无论是否使用不定参数，arguments对象总是包含所有传入函数的参数。 增强的Function构造函数常用来动态创建新的函数 ECMAScript6增强了Function构造函数的功能，支持在创建函数时定义默认参数和不定参数。如：123var add = new Function('frist', 'second = first', 'return first + second')var pickFirst = new Function('...args', 'return args[0]') 展开运算符向Math.max()方法传入一个数组再在数组前添加不定参数中使用的…符号，就无须再调用apply方法了。JavaScript引擎读取这段程序后会将数组分割为各自独立的参数病依次传入，如：123456let values = [25, 50, 75, 100]// 等价于// console.log(Math.max(25, 50, 75, 100)) // 100console.log(Math.max(...values)) // 100console.log(Math.max(values)) // NaN 可以将展开运算符与其他正常传入的参数混合使用。如：123let values = [-25, -50, -75, -100]console.log(Math.max(...values, 0)) // 0 函数的name属性调试时辨别函数(只是协助调试的额外信息，所以不能使用name属性来获取对于函数的引用) 如何选择合适的名称EMCAScript6程序中所有函数的name属性都有一个合适的值。12345678910function doSomething() &#123; // ---&#125;var doAnotherThing = function() &#123; // ---&#125;console.log(doSomething.name) // doSomethingconsole.log(doAnotherThing.name) // doAnotherThing 声明时函数的名称 被赋值为该匿名函数的变量的名称 name属性的特殊情况123456789101112131415161718var doSomeThing = function doSomeThingElse() &#123; // ---&#125;var person = &#123; get firstName() &#123; return 'abc' &#125;, sayName: function() &#123; console.log(this.name) &#125;&#125;console.log(doSomeThing.name) // 'doSomeThing'console.log(person.sayName.name) // 'sayName'console.log(person.firstName.name) // 'get firstName'（浏览器报undefined）原因：person.firstName为'abc'，没有name属性// 要这样检测才对Object.getOwnPropertyDescriptor(person, 'firstName').get.name // "get firstName" 还有两个特例： 通过bind()函数创建的函数，其名称都带有’bound’前缀 通过Function构造函数创建的函数，其名称都带有’anonymous’前缀123456var doSomething = function () &#123; // ---&#125;console.log(doSomething.bind().name) // 'bound doSomething'console.log(new Function().name) // 'anonymous' 明确函数的多重用途JavaScript函数有两个不同的内部方法：[[Call]]和[[Construct]]。当通过new关键字调用函数时，执行的是[[Construct]]函数。、，它负责创建一个通常被称为实例的新对象，然后再执行函数体，将this绑定到实例上；如果不通过new关键字调用函数，则执行[[Call]]函数，从而直接执行代码中的函数体。具有[[Construct]]的函数被统称为构造函数。**切记：不是所有函数都有[[Construct]]方法，因此不是所有函数都可以用new来调用，如箭头函数。 原属性（Metaproperty） new.target为了解决判断函数是否通过new关键字调用的问题，ES6引入了new.target这个元属性。元属性是指非对象的属性，其可以提供非对象目标的补充信息（如new）。当调用函数的[[Construct]方法时，new.target被赋值为new操作符的目标，通常是新创建对象实例，也就是函数体内this的构造函数；如果调用[[Call]]方法，则new.target的值为undefined。 检测一个函数是否通过new关键字调用的：123456789101112function Person(name) &#123; if (typeof new.target !== 'undefined') &#123; // 或者 // if (typeof new.target === Person) &#123; this.name = name &#125; else &#123; throw new Error('必须通过new关键字来调用Person。') &#125;&#125;var person = new Person('Even')var notAPerson = Person.call(person, 'jack') // Uncaught Error: 必须通过new关键字来调用Person。 &gt; 在函数外使用new.target是一个语法错误。块级函数ES5中的严格模式中引入了一个错误提示，当在代码块内部声明函数时会抛出错误：12345678910'use strict'if (true) &#123; // 在ES5中抛出语法错误，在ES6中不报错 function doSomething () &#123; // 空函数 &#125; &#125; 在ES6中，会将doSomething视作一个块级声明，从而可以在定义该函数的代码块内部访问和调用它。如：123456789101112131415'use strict'if (true) &#123; console.log(typeof doSomething) // 'function' // 在ES5中抛出语法错误，在ES6中不报错 function doSomething () &#123; // 空函数 &#125; doSomething()&#125;console.log(typeof doSomething) // 'undefined' 在定义函数的代码块内，块级函数会被提升至顶部，所以typeof doSomething 的值为’function’，这也佐证了，即使在函数定义前使用它，还是能返回正确的值；但是一旦if语句代码块结束执行，doSomething()函数将不再存在。 块级函数的使用场景块级函数与let函数表达式类似，一旦执行过程流出了代码块，函数定义立即被移除。二者的区别是，在该代码块中，块级函数会被提升至块的顶部，二let定义的函数表达式不会被提升。如：1234567891011121314'use strict'if (true) &#123; console.log(typeof doSomething) // Uncaught ReferenceError: doSomething is not defined let doSomething = function() &#123; // 空函数 &#125; doSomething()&#125;console.log(typeof doSomething) // 'undefined' 需要函数提升至代码块的顶部，则选择块级函数；如果不需要，则选择let表达式。 非严格模式下的块级函数在ES6中，即使非严格模式下，也可以声明块级函数，但是和严格模式下稍有不同。这些函数不再被提升至代码块的顶部，而是提升到外围函数或全局作用域的顶部。所有ES6的运行时环境都将执行这一标准。 箭头函数在ES中，箭头函数是其中最有趣的新增特性，它与传统的JavaScript函数有些许不同： 没有this、super、arguments和new.target绑定 箭头函数中的this、super、arguments和new.target由外围最近一层非箭头函数决定。 不能通过new关键字调用 箭头函数没有[[Construct]]方法，所以不能用作构造函数，如果通过new关键字调用箭头函数，程序会抛出错误。 没有原型 由于不可以通过new关键字调用箭头函数，因而没有构建原型的需求，所以箭头函数不存在property这个属性。 不可以改变this的绑定 函数内部的this值不可被改变，在函数的生命周期内始终保持一致。 不支持arguments属性 箭头函数没有arguments绑定，所以必须通过命名参数和不定参数这两种形式访问函数的参数。 不支持重复的命名参数 在传统函数的规定中，只有严格模式下才不能有重复的命名参数。 原因： this绑定在js程序中是常见的错误来源，在函数内很容易对this的值失去控制 限制箭头函数的this值，简化代码执行的过程，有利于JavaScript引擎优化这些操作 箭头函数语法箭头函数语法多变，根据实际的使用场景有多重形式。所有变种都由函数参数、箭头、函数体组成。 当箭头函数只有一个参数时，可以直接写参数名，箭头紧随其后，箭头右侧的表达式被求值后便立即返回，即使没有显式的返回语句。123456let feflect = value =&gt; value// 实际上相当于let feflect = function(value) &#123; return value&#125; 传入两个或两个以上的参数，要在参数的两侧添加一堆小括号。123456let sum = (num1, num2) =&gt; num1 + num2// 实际上相当于let sum = function(num1, num2) &#123; return num1 + num2&#125; 函数没有参数，也要在声明的时候写一组没有内容的小括号123456let gatName = () =&gt; 'Even'// 实际上相当于let gatName = function() &#123; return 'Even'&#125; 为函数编写由多个表达式组成的更传统的函数体，那么需要用或括号包裹函数体，并显式地定义一个返回值12345678let sum = (num1, num2) =&gt; &#123; num1 + num2&#125;// 实际上相当于let sum = function(num1, num2) &#123; return num1 + num2&#125; 创建空函数，需要写一对没有内容的花括号1234let doNothing = () =&gt; &#123;&#125;// 实际上相当于let doNothing = function() &#123;&#125; 如果想在箭头函数外返回一个对象字面量，则需要将改字面量包裹在小括号内123456789let getTempItem = id =&gt; (&#123; id: id, name: 'temp'&#125;)// 实际上相当于let getTempItem = function(id) &#123; return &#123; id: id, name: 'name' &#125;&#125; 将对象字面量包裹在小括号中是为了将其与函数体区分开。 创建立即执行函数表达式定义一个匿名函数并立即调用，自始至终不保存对改对象的引用。创建一个与其他程序隔离的作用域。 123456789let person = function(name) &#123; return &#123; getName:function() &#123; return name &#125; &#125;&#125;('Even')console.log(person.getName()) // 'Even' ES6中只要将箭头函数包裹在小括号中，就可以实现相同的功能：123456789let person = ((name) =&gt; &#123; return &#123; getName:function() &#123; return name &#125; &#125;&#125;)('Even')console.log(person.getName()) // 'Even' 箭头函数没有this绑定 箭头函数中没有this绑定，必须通过查找作用域链来决定其值。如果箭头函数被非箭头函数包含，则this绑定的是最近一层非箭头函数的this；否则this的值被设置为undefined。 箭头函数缺少正常函数所拥有的prototype属性，它的设计初衷是“即用即弃”，所以不能用它来定义新的类型。如果尝试用new关键字调用一个箭头函数，会导致程序抛出错误。 箭头函数的this取决于该函数外部箭头函数的this值，且不能通过call()、apply()、bind()方法改变this的值。 箭头函数和数组1var result = values.sort((a, b) =&gt; a - b) // 排序 诸如sort()、map()、reduce()这些可以接受回掉函数的数组方法，都可以通过箭头函数语法简化编码过程并减少编码量。 箭头函数没有arguments对象箭头函数没有自己的arguments对象，且未来无论函数在哪个上下文中执行，箭头函数始终可以访问外围函数的arguments对象。 箭头函数的辨别尽管箭头函数与传统函数的语法不同，但它同样可以被识别出来。1234var comparator = (a, b) =&gt; a-bconsole.log(typeof comparator) // 'function'console.log(comparator instanceof Function) // true 尾调用优化尾调用指的是函数作为另一个函数的最后一条语句被调用。如：123function doSomething() &#123; return doSomethingElse() // 尾调用&#125; 在ES5引擎中，尾调用的实现与其他函数调用的实现类似：创建一个新的栈帧（stack frame），将其推入调用栈来表示函数调用。也就是说，在循环环境中，每一个未用完的栈帧都会保存在内存中，当调用栈变得过大时会造成程序问题。 EMCAScript6中尾调用优化EMCAScript6缩短了严格模式下调用栈的大小（非严格模式下不收影响），如果满足以下条件，尾调用不再创建新的栈帧，而是清除并重用当前栈帧： 尾调用不访问当前栈帧的变量（也就是说函数不是一个闭包） 在函数内部，尾调用是最后一条语句 尾调用的结果作为函数值返回 如何利用尾调用优化尾调用优化发生在引擎背后，除非尝试优化这个函数，否则无须考虑此类问题。递归函数是最主要的应用场景，此时尾调用优化效果最显著。]]></content>
      <categories>
        <category>JavaScript</category>
        <category>ECMAScript2015</category>
        <category>《深入理解ES6》笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
        <tag>ECMAScript2015</tag>
        <tag>《深入理解ES6》笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二、字符串和正则表达式]]></title>
    <url>%2F2017%2F07%2F17%2F%E4%BA%8C%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[更好的Unicode支持UTF-16码位 UTF-16引入了代理对（surrogate pair），其规定用两个16位编码单元表示一个码位。也就是说，字符串里的字符有两种，一种是由一个编码单元16位表示的BMP字符，一种是由两个编码单元32位表示的辅助平面字符。 ES6强制使用UTF-16字符串编码，并按照这种字符编码来标准化字符串操作，在JavaScript中增加了专门针对代理对的功能。 codePointAt()方法codePointAt()方法接受编码单元的位置而非字符串的位置作为参数，返回与字符串中给定位置对应的码位，既一个整数值。 对于BMP字符集中的字符，codePointAt()和charCodeAt()方法的相同，而对于非BMP字符集来说返回值则不同。charCodeAt()方法返回的只是位置0处的第一个编码单元，而codePointAt()返回完整的码位，即使这个码位包含多个编码单元。 要检测一个字符占用的编码单元数量，最简单的方法是调用字符的codePointAt()方法：12345function is32Bit(c) &#123; return c.codePointAt(c) &gt; 0xFFFF&#125;console.log('a') // false 用16位表示的字符集上界为十六进制FFFF，所以超过这个上界的码位一定由两个编码单元来表示，总共32位。 String.fromCodePoint()方法String.fromCodePoint()方法根据指定的码位生成一个字符：1console.log(String.fromCodePoint(134071)) // '𠮷' 可以将String.fromCodePoint()看成是完整版的String.fromCharCode()。对应BMP中所有的字符，两方法执行结果相同。只有传递非BMP字符的码位作为参数，二者的执行结果才有可能不同。 normalize()方法（国际化应用中常使用）normalize()方法提供Unicode的标准化形式： 以标准等价方式分解，然后以标准等价方式重组(‘NFC’),默认选项。 以标准等价方式分解(‘NFD’)。 以兼容等价方式分解(‘NFKC’)。 以兼容等价方式分解，然后以标准等价方式重组(‘NFKD’)。 需牢记：在对比字符串之前，一定要先把它们标准化为同一种形式:12345678910111213let normalized = values.map(function(text) &#123; retrun text.normalize()&#125;)nomralized.sort(funtion(first, second) &#123; if (first &lt; second) &#123; return -1 &#125; else if (first === second) &#123; return 0 &#125; else &#123; return 1 &#125;&#125;) 如果相对原始数组进行排序，可以在比较函数中添加normalize()方法：123456789101112values.sort(funtion(first, second) &#123; let firstNormalized = first.normalize(), secondNormalized = second.normalize() if (firstNormalized &lt; secondNormalized) &#123; return -1 &#125; else if (firstNormalized === secondNormalized) &#123; return 0 &#125; else &#123; return 1 &#125;&#125;) 正则表达式u修饰符解决默认将字符串中的每个字符按照16位编码单元处理的问题。 u修饰符实例当一个正则表达式添加了u修饰符时，它就从编码单元操作模式切换为字符模式，如此一来正则表达式就不会视代理对为两个字符。 12345let text = '𠮷'console.log(text.length) // 2console.log(/^.$/.test(text)) // false /^.$/匹配所有单字符字符串，'𠮷'由两个编码单元组成console.log(/^.$/u.test(text)) // true 计算码位数量es6检测字符串的length属性仍然返回字符串编码单元的数量。可以通过正则表达式的u修饰符来解决：1234567function codePointlength(text) &#123; let result = text.match(/[\s\S]/gu) return result ? result.length : 0&#125;console.log(codePointlength('abc')) // 3console.log(codePointlength('𠮷bc')) // 3 此方法有效，但运行效率低（可以通过字符串迭代器来解决） 检测u修饰符支持检测当前浏览器是否支持u修饰符，最安全的方式是通过以下函数：12345678function hasRegExpU() &#123; try &#123; var pattern = new RegExp('.', 'u') return true &#125; catch (ex) &#123; return false &#125;&#125; 其他字符串变更字符串中的子串识别indexOf()拓展： includes()方法，如果在字符串中检测到指定文本则返回true，否则返回false startsWith()方法，从字符串起始位置检测 endsWith()方法，从字符串结束部分检测 以上3个方法都接收两个参数==&gt; (‘要搜索的文本’, ‘开始搜索的位置的索引’)12345678910111213let msg = 'Hello World!'console.log(msg.startsWith('Hello')) // trueconsole.log(msg.endsWith('!')) // trueconsole.log(msg.includes('o')) // trueconsole.log(msg.startsWith('o')) // falseconsole.log(msg.endsWith('World!')) // trueconsole.log(msg.includes('x')) // falseconsole.log(msg.startsWith('o', 4)) // trueconsole.log(msg.endsWith('o', 8)) // trueconsole.log(msg.includes('o', 8)) // false 这三个方法如果没有按照要求传入字符串，而是传入正则表达式，会触发错误。indexOf()和lastIndexOf()则不会,它们会把传入的正则表达式当作字符串并搜索它。 repeat()方法repeat()方法接受一个number类型的参数，表示字符串重复的次数，返回值是当前字符串重复一定次数的新字符串。 123456// 缩进指定数量的空格let indent = ' '.repeat(4), indentLevel = 0// 当需要增加缩进时let newIndent = indent.repeat(++indentLevel) 其他正则表达式语法变更正则表达式y修饰符y修饰符会影响正则表达式的搜索过程中的sticky属性，当在字符串中开始字符匹配时，它会通知搜索从正则表达式的lastIndex属性开始进行，如果在指定位置没能成功匹配，则停止继续匹配。记住两点： 只有调用exec()和test()这些正则表达式对象的方法时才会涉及lastIndex属性； 调用字符串方法，如match()，不会触发粘滞行为。 检测y修饰符是否存在（通过属性名来检测）：123let pattern = /hello\d/yconsole.log(pattern.sticky) // true 检测引擎的支持程度：12345678910function hasRegExpY () &#123; try &#123; var pattern = new RegExp('.', 'y') return true &#125; catch (ex) &#123; return false &#125;&#125;hasRegExpY() 正则表达式的复制es5中通过给RegExp构造函数传递正则表达式作为参数来复制这个正则表达式，如：12var re1 = /ab/i re2 = new RegExp(re1) 但是给RegExp构造函数提供第二个参数，为正则表达式指定一个修饰符，则代码无法运行：1234var re1 = /ab/i // es5中抛出错误，es6中正常 re2 = new RegExp(re1, 'g') // es6中第二个参数修改第一个参数的修饰符 flags属性ES6中用来获取正则表达式的修饰符ES5和ES6中通过source属性获取正则表达式的文本 ES5中这样获取：1234567function getFlags(re) &#123; var text = re.toString() return text.substring(text.lastIndexOf('/')+1, text.length)&#125;var re = /ab/gconsole.log(getFlags(re)) // 'g' flags属性和source属性都是只读的原型属性访问器，对齐只设置了getter方法。访问flags属性会返回所有应用于当前正则表达式的修饰符字符串。如：1234let re = /ab/gconsole.log(re.source) // 'ab'console.log(re.flags) // 'g' 模板字面量ES6模板字面量语法支持创建专用领域语言（DSL,是与JavaScript概念相反的编程语言，通常是指某些具体且有限的目标设计的语言)。 模板字面量是拓展ECMAScript基础语法的语法糖，其提供一套生成、查询并操作来自其他语言里的内容的DSL，且可以免受注入攻击。 新特性： 多行字符串 基本的字符串格式化（将变量的值嵌入字符串的能力） HTML转义（向HTML插入经过安全转换后的字符串的能力） 基础语法 用反撇号（`）替换单、双引号 在字符串中使用反撇号，要用反斜杠（\）将其转义 在模板字面量中，不需要转义单、双引号 多行字符串在ES6之前，通常依靠数组或字符串拼接的方法来创建多行字符串，如：12345678var message = [ 'Multiline ', 'string'].join('\n')// 或者let message = 'Multiline \n' + 'string' 简化多行字符串 需要在字符串中添加新的一行，只需在代码中直接换行 在反撇号中所有的空白符都属于字符串的一部分，所以要千万小心缩进。如果要通过适当的缩进来对齐文本，可以考虑在多行模板字面量的第一行留白，并在后面几行中缩进。如: 1234let html = `&lt;div&gt; &lt;h1&gt;Title&lt;/h1&gt;&lt;/div&gt;`.trim() 也可以在模板字面量中显式的使用\n,来指明插入新行的位置 标签模板标签指在模板字面量第一个反撇号（`）前方标注的字符串：1let message = tag`Hello World` 在这个示例中，应用于模板字面量Hello World的模板标签是tag。 定义标签标签可以是一个函数，调用时传入加工过的模板字面量各部分数据，但必须结合每个部分来创建结果。第一个参数是一个数组，包含JavaScript解释过后的字面量字符串，第一个参数后的所以参数都是每一个占位符的解释值。 标签函数通常使用不定参数特性来定义占位符，从而简化数据处理的过程，如：123function tag (literals, ...substitutions) &#123; // 返回一个字符串&#125; literals[0]总是字符串的始端，literals[literals.length - 1]总是字符串的结尾。这样，substitutions的数量总比literals的数量少一个，也意味着substitutions.length === literals.length-1总为true。、 模拟模板字面量的默认行为：1234567891011121314151617181920function passthru (literals, substitutions) &#123; let result = '' // 根据substitutions的数量来确定循环的执行次数(用literals常会越界) for (let i = 0; i &lt; substitutions.length; i++) &#123; result += literals[i] result += substitutions[i] &#125; // 合并最后一个literal result += literals[literals.length - 1] return result&#125;let count = 10, price = 0.25 message = passthru`$&#123;count&#125; items cost $$&#123;(count*price).toFixed(2)&#125;.`console.log(message) // '10 items cost $2.50.' 在模板字面量中使用原始值通过模板标签可以访问到原生字符串信息（转换之前的原生字符串），最简单的方法是使用内建的String.row标签：123456let message1 = `Multiline\nstring` message2 = String.row`Multiline\nstring`console.log(message1) // 'Multiline // string'console.log(message2) // 'Multiline\nstring']]></content>
      <categories>
        <category>JavaScript</category>
        <category>ECMAScript2015</category>
        <category>《深入理解ES6》笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
        <tag>ECMAScript2015</tag>
        <tag>《深入理解ES6》笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一、块级作用域绑定]]></title>
    <url>%2F2017%2F07%2F16%2F%E4%B8%80%E3%80%81%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%BB%91%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[原因：var声明和变量提升（Hoisting）机制 块级声明块级声明用于声明在指定块之外无法访问的变量 块级作用域（词法作用域）： 函数内部 块中{} let声明（变量）用let替代var来声明变量，可以把变量作用域限制在当前代码块中。由于let声明不会被提升，因此开发者通常使用let声明语句放在封闭代码块的顶部，一遍整个代码块都可以访问 禁止重声明同一作用域中不能用let重复定义已经存在的标识符，否则会抛出错误。但如果当前作用域内嵌另一个作用域，便可在内嵌作用域中用let声明同名变量。 const声明（常量） const和let声明的都是块级标识符 其值一旦被设定都不可更改（不可再次赋值） 每个通过const声明的常量必须进行初始化（赋值） 和其他语言中常量不同的是：es6中如果常量是对象，则对象中的值可以修改（修改对象的属性值）1234567891011const person = &#123; name: &quot;Nicholas&quot;&#125;// 可以修改对象属性的值person.name = &quot;Greg&quot;// 抛出语法错误person = &#123; name： &quot;Greg&quot;&#125; 修改绑定的值不对报错，但直接给person赋值，既修改person的绑定，会抛出错误。const声明不允许修改绑定，但允许修改绑定的值 临时死区（Temporal Dead Zone/TDZ） 临时死区（Temporal Dead Zone/TDZ），常被用来描述let和const的不提示效果 只用执行过变量声明语句后，变量才会从TDZ中移出，然后才能正常访问 但在let声明的作用域外对变量使用typeof则不会报错：12345console.log(typeof value) // &quot;undefined&quot;if (condition) &#123; let value = &quot;blue&quot;&#125; typeof是在声明变量value的代码块外执行的，此时value并不在TDZ中。也就意味着不存在value这个绑定，typeof最终返回”undefined” 循环中的块作用域绑定123456for (let i=0; i&lt;10; i++) &#123; prosess(items[i])&#125;// i在这里不可访问，抛出错误console.log(i) 循环中的函数 长久以来，var声明让开发者在循环中创建函数变得异常困难，因为变量倒了循环之外仍能访问。ES6中let和const提供的块级绑定让我们无需再这么折腾 开发者在循环中使用立即调用函数表达式（IIFE），以强制生成计数器变量的副本 循环中的let声明 每次循环的时候let声明都会创建一个新变量i，并将其初始化为i的当前值 let声明在循环内部的行为是标准中专门定义的，它不一定与let的不提升特性相关，理解这点至关重要 循环中的const声明 对应for循环，可以在初始化变量时使用const，但更改这个变量时就会抛出错误 在for-in和for-of循环中，因为在每次迭代不会修改已有绑定，而是创建一个新绑定，所以不会抛出错误 全局块作用域绑定 当var被用于全局作用域时，它会创建一个新的全局变量作为全局对象（浏览器环境中的window对象）的属性 如果不想为全局对象创建属性，使用let和const则安全得多 如果希望在全局对象下定义变量，仍然可以使用var。这种情况常见于在浏览器中跨frame或跨window访问 块级绑定最佳实践的进化新的理念：默认使用const，只有确实需要改变变量的值时使用let。因为大部分变量的值在初始化后不应再改变，而预料之外的变量值的改变是很多bug的源头。（某种程度上实现代码的不可变，从而防止某些错误的产生）]]></content>
      <categories>
        <category>JavaScript</category>
        <category>ECMAScript2015</category>
        <category>《深入理解ES6》笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
        <tag>ECMAScript2015</tag>
        <tag>《深入理解ES6》笔记</tag>
      </tags>
  </entry>
</search>