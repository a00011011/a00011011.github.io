<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[二、字符串和正则表达式]]></title>
    <url>%2F2017%2F07%2F17%2F%E4%BA%8C%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[更好的Unicode支持UTF-16码位 UTF-16引入了代理对（surrogate pair），其规定用两个16位编码单元表示一个码位。也就是说，字符串里的字符有两种，一种是由一个编码单元16位表示的BMP字符，一种是由两个编码单元32位表示的辅助平面字符。 ES6强制使用UTF-16字符串编码，并按照这种字符编码来标准化字符串操作，在JavaScript中增加了专门针对代理对的功能。 codePointAt()方法codePointAt()方法接受编码单元的位置而非字符串的位置作为参数，返回与字符串中给定位置对应的码位，既一个整数值。 对于BMP字符集中的字符，codePointAt()和charCodeAt()方法的相同，而对于非BMP字符集来说返回值则不同。charCodeAt()方法返回的只是位置0处的第一个编码单元，而codePointAt()返回完整的码位，即使这个码位包含多个编码单元。 要检测一个字符占用的编码单元数量，最简单的方法是调用字符的codePointAt()方法：12345function is32Bit(c) &#123; return c.codePointAt(c) &gt; 0xFFFF&#125;console.log('a') // false 用16位表示的字符集上界为十六进制FFFF，所以超过这个上界的码位一定由两个编码单元来表示，总共32位。 String.fromCodePoint()方法String.fromCodePoint()方法根据指定的码位生成一个字符：1console.log(String.fromCodePoint(134071)) // '𠮷' 可以将String.fromCodePoint()看成是完整版的String.fromCharCode()。对应BMP中所有的字符，两方法执行结果相同。只有传递非BMP字符的码位作为参数，二者的执行结果才有可能不同。 normalize()方法（国际化应用中常使用）normalize()方法提供Unicode的标准化形式： 以标准等价方式分解，然后以标准等价方式重组(‘NFC’),默认选项。 以标准等价方式分解(‘NFD’)。 以兼容等价方式分解(‘NFKC’)。 以兼容等价方式分解，然后以标准等价方式重组(‘NFKD’)。 需牢记：在对比字符串之前，一定要先把它们标准化为同一种形式:12345678910111213let normalized = values.map(function(text) &#123; retrun text.normalize()&#125;)nomralized.sort(funtion(first, second) &#123; if (first &lt; second) &#123; return -1 &#125; else if (first === second) &#123; return 0 &#125; else &#123; return 1 &#125;&#125;) 如果相对原始数组进行排序，可以在比较函数中添加normalize()方法：123456789101112values.sort(funtion(first, second) &#123; let firstNormalized = first.normalize(), secondNormalized = second.normalize() if (firstNormalized &lt; secondNormalized) &#123; return -1 &#125; else if (firstNormalized === secondNormalized) &#123; return 0 &#125; else &#123; return 1 &#125;&#125;) 正则表达式u修饰符解决默认将字符串中的每个字符按照16位编码单元处理的问题。 u修饰符实例当一个正则表达式添加了u修饰符时，它就从编码单元操作模式切换为字符模式，如此一来正则表达式就不会视代理对为两个字符。 12345let text = '𠮷'console.log(text.length) // 2console.log(/^.$/.test(text)) // false /^.$/匹配所有单字符字符串，'𠮷'由两个编码单元组成console.log(/^.$/u.test(text)) // true 计算码位数量es6检测字符串的length属性仍然返回字符串编码单元的数量。可以通过正则表达式的u修饰符来解决：1234567function codePointlength(text) &#123; let result = text.match(/[\s\S]/gu) return result ? result.length : 0&#125;console.log(codePointlength('abc')) // 3console.log(codePointlength('𠮷bc')) // 3 此方法有效，但运行效率低（可以通过字符串迭代器来解决） 检测u修饰符支持检测当前浏览器是否支持u修饰符，最安全的方式是通过以下函数：12345678function hasRegExpU() &#123; try &#123; var pattern = new RegExp('.', 'u') return true &#125; catch (ex) &#123; return false &#125;&#125; 其他字符串变更字符串中的子串识别indexOf()拓展： includes()方法，如果在字符串中检测到指定文本则返回true，否则返回false startsWith()方法，从字符串起始位置检测 endsWith()方法，从字符串结束部分检测 以上3个方法都接收两个参数==&gt; (‘要搜索的文本’, ‘开始搜索的位置的索引’)12345678910111213let msg = 'Hello World!'console.log(msg.startsWith('Hello')) // trueconsole.log(msg.endsWith('!')) // trueconsole.log(msg.includes('o')) // trueconsole.log(msg.startsWith('o')) // falseconsole.log(msg.endsWith('World!')) // trueconsole.log(msg.includes('x')) // falseconsole.log(msg.startsWith('o', 4)) // trueconsole.log(msg.endsWith('o', 8)) // trueconsole.log(msg.includes('o', 8)) // false 这三个方法如果没有按照要求传入字符串，而是传入正则表达式，会触发错误。indexOf()和lastIndexOf()则不会,它们会把传入的正则表达式当作字符串并搜索它。 repeat()方法repeat()方法接受一个number类型的参数，表示字符串重复的次数，返回值是当前字符串重复一定次数的新字符串。 123456// 缩进指定数量的空格let indent = ' '.repeat(4), indentLevel = 0// 当需要增加缩进时let newIndent = indent.repeat(++indentLevel) 其他正则表达式语法变更正则表达式y修饰符y修饰符会影响正则表达式的搜索过程中的sticky属性，当在字符串中开始字符匹配时，它会通知搜索从正则表达式的lastIndex属性开始进行，如果在指定位置没能成功匹配，则停止继续匹配。记住两点： 只有调用exec()和test()这些正则表达式对象的方法时才会涉及lastIndex属性； 调用字符串方法，如match()，不会触发粘滞行为。 检测y修饰符是否存在（通过属性名来检测）：123let pattern = /hello\d/yconsole.log(pattern.sticky) // true 检测引擎的支持程度：12345678910function hasRegExpY () &#123; try &#123; var pattern = new RegExp('.', 'y') return true &#125; catch (ex) &#123; return false &#125;&#125;hasRegExpY() 正则表达式的复制es5中通过给RegExp构造函数传递正则表达式作为参数来复制这个正则表达式，如：12var re1 = /ab/i re2 = new RegExp(re1) 但是给RegExp构造函数提供第二个参数，为正则表达式指定一个修饰符，则代码无法运行：1234var re1 = /ab/i // es5中抛出错误，es6中正常 re2 = new RegExp(re1, 'g') // es6中第二个参数修改第一个参数的修饰符 flags属性ES6中用来获取正则表达式的修饰符ES5和ES6中通过source属性获取正则表达式的文本 ES5中这样获取：1234567function getFlags(re) &#123; var text = re.toString() return text.substring(text.lastIndexOf('/')+1, text.length)&#125;var re = /ab/gconsole.log(getFlags(re)) // 'g' flags属性和source属性都是只读的原型属性访问器，对齐只设置了getter方法。访问flags属性会返回所有应用于当前正则表达式的修饰符字符串。如：1234let re = /ab/gconsole.log(re.source) // 'ab'console.log(re.flags) // 'g' 模板字面量ES6模板字面量语法支持创建专用领域语言（DSL,是与JavaScript概念相反的编程语言，通常是指某些具体且有限的目标设计的语言)。 模板字面量是拓展ECMAScript基础语法的语法糖，其提供一套生成、查询并操作来自其他语言里的内容的DSL，且可以免受注入攻击。 新特性： 多行字符串 基本的字符串格式化（将变量的值嵌入字符串的能力） HTML转义（向HTML插入经过安全转换后的字符串的能力） 基础语法 用反撇号（`）替换单、双引号 在字符串中使用反撇号，要用反斜杠（\）将其转义 在模板字面量中，不需要转义单、双引号 多行字符串在ES6之前，通常依靠数组或字符串拼接的方法来创建多行字符串，如：12345678var message = [ 'Multiline ', 'string'].join('\n')// 或者let message = 'Multiline \n' + 'string' 简化多行字符串 需要在字符串中添加新的一行，只需在代码中直接换行 在反撇号中所有的空白符都属于字符串的一部分，所以要千万小心缩进。如果要通过适当的缩进来对齐文本，可以考虑在多行模板字面量的第一行留白，并在后面几行中缩进。如: 1234let html = `&lt;div&gt; &lt;h1&gt;Title&lt;/h1&gt;&lt;/div&gt;`.trim() 也可以在模板字面量中显式的使用\n,来指明插入新行的位置 标签模板标签指在模板字面量第一个反撇号（`）前方标注的字符串：1let message = tag`Hello World` 在这个示例中，应用于模板字面量Hello World的模板标签是tag。 定义标签标签可以是一个函数，调用时传入加工过的模板字面量各部分数据，但必须结合每个部分来创建结果。第一个参数是一个数组，包含JavaScript解释过后的字面量字符串，第一个参数后的所以参数都是每一个占位符的解释值。 标签函数通常使用不定参数特性来定义占位符，从而简化数据处理的过程，如：123function tag (literals, ...substitutions) &#123; // 返回一个字符串&#125; literals[0]总是字符串的始端，literals[literals.length - 1]总是字符串的结尾。这样，substitutions的数量总比literals的数量少一个，也意味着substitutions.length === literals.length-1总为true。、 模拟模板字面量的默认行为：1234567891011121314151617181920function passthru (literals, substitutions) &#123; let result = '' // 根据substitutions的数量来确定循环的执行次数(用literals常会越界) for (let i = 0; i &lt; substitutions.length; i++) &#123; result += literals[i] result += substitutions[i] &#125; // 合并最后一个literal result += literals[literals.length - 1] return result&#125;let count = 10, price = 0.25 message = passthru`$&#123;count&#125; items cost $$&#123;(count*price).toFixed(2)&#125;.`console.log(message) // '10 items cost $2.50.' 在模板字面量中使用原始值通过模板标签可以访问到原生字符串信息（转换之前的原生字符串），最简单的方法是使用内建的String.row标签：123456let message1 = `Multiline\nstring` message2 = String.row`Multiline\nstring`console.log(message1) // 'Multiline // string'console.log(message2) // 'Multiline\nstring']]></content>
      <categories>
        <category>JavaScript</category>
        <category>ECMAScript2015</category>
        <category>《深入理解ES6》笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
        <tag>ECMAScript2015</tag>
        <tag>《深入理解ES6》笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一、块级作用域绑定]]></title>
    <url>%2F2017%2F07%2F16%2F%E4%B8%80%E3%80%81%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%BB%91%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[原因：var声明和变量提升（Hoisting）机制 块级声明块级声明用于声明在指定块之外无法访问的变量 块级作用域（词法作用域）： 函数内部 块中{} let声明（变量）用let替代var来声明变量，可以把变量作用域限制在当前代码块中。由于let声明不会被提升，因此开发者通常使用let声明语句放在封闭代码块的顶部，一遍整个代码块都可以访问 禁止重声明同一作用域中不能用let重复定义已经存在的标识符，否则会抛出错误。但如果当前作用域内嵌另一个作用域，便可在内嵌作用域中用let声明同名变量。 const声明（常量） const和let声明的都是块级标识符 其值一旦被设定都不可更改（不可再次赋值） 每个通过const声明的常量必须进行初始化（赋值） 和其他语言中常量不同的是：es6中如果常量是对象，则对象中的值可以修改（修改对象的属性值）1234567891011const person = &#123; name: &quot;Nicholas&quot;&#125;// 可以修改对象属性的值person.name = &quot;Greg&quot;// 抛出语法错误person = &#123; name： &quot;Greg&quot;&#125; 修改绑定的值不对报错，但直接给person赋值，既修改person的绑定，会抛出错误。const声明不允许修改绑定，但允许修改绑定的值 临时死区（Temporal Dead Zone/TDZ） 临时死区（Temporal Dead Zone/TDZ），常被用来描述let和const的不提示效果 只用执行过变量声明语句后，变量才会从TDZ中移出，然后才能正常访问 但在let声明的作用域外对变量使用typeof则不会报错：12345console.log(typeof value) // &quot;undefined&quot;if (condition) &#123; let value = &quot;blue&quot;&#125; typeof是在声明变量value的代码块外执行的，此时value并不在TDZ中。也就意味着不存在value这个绑定，typeof最终返回”undefined” 循环中的块作用域绑定123456for (let i=0; i&lt;10; i++) &#123; prosess(items[i])&#125;// i在这里不可访问，抛出错误console.log(i) 循环中的函数 长久以来，var声明让开发者在循环中创建函数变得异常困难，因为变量倒了循环之外仍能访问。ES6中let和const提供的块级绑定让我们无需再这么折腾 开发者在循环中使用立即调用函数表达式（IIFE），以强制生成计数器变量的副本 循环中的let声明 每次循环的时候let声明都会创建一个新变量i，并将其初始化为i的当前值 let声明在循环内部的行为是标准中专门定义的，它不一定与let的不提升特性相关，理解这点至关重要 循环中的const声明 对应for循环，可以在初始化变量时使用const，但更改这个变量时就会抛出错误 在for-in和for-of循环中，因为在每次迭代不会修改已有绑定，而是创建一个新绑定，所以不会抛出错误 全局块作用域绑定 当var被用于全局作用域时，它会创建一个新的全局变量作为全局对象（浏览器环境中的window对象）的属性 如果不想为全局对象创建属性，使用let和const则安全得多 如果希望在全局对象下定义变量，仍然可以使用var。这种情况常见于在浏览器中跨frame或跨window访问 块级绑定最佳实践的进化新的理念：默认使用const，只有确实需要改变变量的值时使用let。因为大部分变量的值在初始化后不应再改变，而预料之外的变量值的改变是很多bug的源头。（某种程度上实现代码的不可变，从而防止某些错误的产生）]]></content>
      <categories>
        <category>JavaScript</category>
        <category>ECMAScript2015</category>
        <category>《深入理解ES6》笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
        <tag>ECMAScript2015</tag>
        <tag>《深入理解ES6》笔记</tag>
      </tags>
  </entry>
</search>