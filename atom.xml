<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>EvenYip&#39;s Notes</title>
  <subtitle>带着未知与怀疑，保持平静</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-07-16T14:34:55.932Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>叶爷</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>一、块级作用域绑定</title>
    <link href="http://yoursite.com/2017/07/16/%E4%B8%80%E3%80%81%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%BB%91%E5%AE%9A/"/>
    <id>http://yoursite.com/2017/07/16/一、块级作用域绑定/</id>
    <published>2017-07-16T07:05:58.000Z</published>
    <updated>2017-07-16T14:34:55.932Z</updated>
    
    <content type="html"><![CDATA[<p>原因：var声明和变量提升（Hoisting）机制</p>
<hr>
<h1 id="块级声明"><a href="#块级声明" class="headerlink" title="块级声明"></a>块级声明</h1><p>块级声明用于声明在指定块之外无法访问的变量</p>
<h2 id="块级作用域（词法作用域）："><a href="#块级作用域（词法作用域）：" class="headerlink" title="块级作用域（词法作用域）："></a>块级作用域（词法作用域）：</h2><ul>
<li>函数内部</li>
<li>块中{}</li>
</ul>
<h3 id="let声明（变量）"><a href="#let声明（变量）" class="headerlink" title="let声明（变量）"></a>let声明（变量）</h3><p>用let替代var来声明变量，可以把变量作用域限制在当前代码块中。由于let声明不会被提升，因此开发者通常使用let声明语句放在封闭代码块的顶部，一遍整个代码块都可以访问</p>
<h3 id="禁止重声明"><a href="#禁止重声明" class="headerlink" title="禁止重声明"></a>禁止重声明</h3><p>同一作用域中不能用let重复定义已经存在的标识符，否则会抛出错误。但如果当前作用域内嵌另一个作用域，便可在内嵌作用域中用let声明同名变量。</p>
<h3 id="const声明（常量）"><a href="#const声明（常量）" class="headerlink" title="const声明（常量）"></a>const声明（常量）</h3><ul>
<li>const和let声明的都是块级标识符</li>
<li>其值一旦被设定都不可更改（不可再次赋值）</li>
<li>每个通过const声明的常量必须进行初始化（赋值）</li>
<li><strong>和其他语言中常量不同的是：es6中如果常量是对象，则对象中的值可以修改（修改对象的属性值）</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">const person = &#123;</div><div class="line">    name: &quot;Nicholas&quot;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 可以修改对象属性的值</div><div class="line">person.name = &quot;Greg&quot;</div><div class="line"></div><div class="line">// 抛出语法错误</div><div class="line">person = &#123;</div><div class="line">    name： &quot;Greg&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>修改绑定的值不对报错，但直接给person赋值，既修改person的绑定，会抛出错误。<br><strong>const声明不允许修改绑定，但允许修改绑定的值</strong></p>
<h3 id="临时死区（Temporal-Dead-Zone-TDZ）"><a href="#临时死区（Temporal-Dead-Zone-TDZ）" class="headerlink" title="临时死区（Temporal Dead Zone/TDZ）"></a>临时死区（Temporal Dead Zone/TDZ）</h3><ul>
<li>临时死区（Temporal Dead Zone/TDZ），常被用来描述let和const的不提示效果</li>
<li>只用执行过变量声明语句后，变量才会从TDZ中移出，然后才能正常访问</li>
<li>但在let声明的作用域外对变量使用typeof则不会报错：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">console.log(typeof value)    // &quot;undefined&quot;</div><div class="line"></div><div class="line">if (condition) &#123;</div><div class="line">    let value = &quot;blue&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>typeof是在声明变量value的代码块外执行的，此时value并不在TDZ中。也就意味着不存在value这个绑定，typeof最终返回”undefined”</p>
<hr>
<h1 id="循环中的块作用域绑定"><a href="#循环中的块作用域绑定" class="headerlink" title="循环中的块作用域绑定"></a>循环中的块作用域绑定</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">for (let i=0; i&lt;10; i++) &#123;</div><div class="line">    prosess(items[i])</div><div class="line">&#125;</div><div class="line"></div><div class="line">// i在这里不可访问，抛出错误</div><div class="line">console.log(i)</div></pre></td></tr></table></figure>
<h2 id="循环中的函数"><a href="#循环中的函数" class="headerlink" title="循环中的函数"></a>循环中的函数</h2><ul>
<li>长久以来，var声明让开发者在循环中创建函数变得异常困难，因为变量倒了循环之外仍能访问。ES6中let和const提供的块级绑定让我们无需再这么折腾</li>
<li>开发者在循环中使用立即调用函数表达式（IIFE），以强制生成计数器变量的副本</li>
</ul>
<h2 id="循环中的let声明"><a href="#循环中的let声明" class="headerlink" title="循环中的let声明"></a>循环中的let声明</h2><ul>
<li>每次循环的时候let声明都会创建一个新变量i，并将其初始化为i的当前值</li>
<li><strong>let声明在循环内部的行为是标准中专门定义的，它不一定与let的不提升特性相关，理解这点至关重要</strong></li>
</ul>
<h2 id="循环中的const声明"><a href="#循环中的const声明" class="headerlink" title="循环中的const声明"></a>循环中的const声明</h2><ul>
<li>对应for循环，可以在初始化变量时使用const，但更改这个变量时就会抛出错误</li>
<li>在for-in和for-of循环中，因为在每次迭代不会修改已有绑定，而是创建一个新绑定，所以不会抛出错误</li>
</ul>
<hr>
<h1 id="全局块作用域绑定"><a href="#全局块作用域绑定" class="headerlink" title="全局块作用域绑定"></a>全局块作用域绑定</h1><ul>
<li>当var被用于全局作用域时，它会创建一个新的全局变量作为全局对象（浏览器环境中的window对象）的属性</li>
<li>如果不想为全局对象创建属性，使用let和const则安全得多</li>
<li>如果希望在全局对象下定义变量，仍然可以使用var。这种情况常见于在浏览器中跨frame或跨window访问</li>
</ul>
<hr>
<h1 id="块级绑定最佳实践的进化"><a href="#块级绑定最佳实践的进化" class="headerlink" title="块级绑定最佳实践的进化"></a>块级绑定最佳实践的进化</h1><p><strong>新的理念：</strong><br>默认使用const，只有确实需要改变变量的值时使用let。因为大部分变量的值在初始化后不应再改变，而预料之外的变量值的改变是很多bug的源头。（某种程度上实现代码的不可变，从而防止某些错误的产生）</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原因：var声明和变量提升（Hoisting）机制&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;块级声明&quot;&gt;&lt;a href=&quot;#块级声明&quot; class=&quot;headerlink&quot; title=&quot;块级声明&quot;&gt;&lt;/a&gt;块级声明&lt;/h1&gt;&lt;p&gt;块级声明用于声明在指定块之外无法访问的变量&lt;/p
    
    </summary>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
      <category term="ECMAScript2015" scheme="http://yoursite.com/categories/JavaScript/ECMAScript2015/"/>
    
      <category term="《深入理解ES6》笔记" scheme="http://yoursite.com/categories/JavaScript/ECMAScript2015/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
      <category term="ES6" scheme="http://yoursite.com/tags/ES6/"/>
    
      <category term="ECMAScript2015" scheme="http://yoursite.com/tags/ECMAScript2015/"/>
    
      <category term="《深入理解ES6》笔记" scheme="http://yoursite.com/tags/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
</feed>
